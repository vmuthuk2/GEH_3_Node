// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: StateCollection.proto

#ifndef PROTOBUF_StateCollection_2eproto__INCLUDED
#define PROTOBUF_StateCollection_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace freedm {
namespace broker {
namespace sc {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_StateCollection_2eproto();
void protobuf_AssignDesc_StateCollection_2eproto();
void protobuf_ShutdownFile_StateCollection_2eproto();

class MarkerMessage;
class DeviceSignalStateMessage;
class StateMessage;
class DeviceSignalRequestMessage;
class RequestMessage;
class CollectedStateMessage;
class StateCollectionMessage;

// ===================================================================

class MarkerMessage : public ::google::protobuf::Message {
 public:
  MarkerMessage();
  virtual ~MarkerMessage();

  MarkerMessage(const MarkerMessage& from);

  inline MarkerMessage& operator=(const MarkerMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarkerMessage& default_instance();

  void Swap(MarkerMessage* other);

  // implements Message ----------------------------------------------

  MarkerMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarkerMessage& from);
  void MergeFrom(const MarkerMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string source = 1;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 1;
  inline const ::std::string& source() const;
  inline void set_source(const ::std::string& value);
  inline void set_source(const char* value);
  inline void set_source(const char* value, size_t size);
  inline ::std::string* mutable_source();
  inline ::std::string* release_source();
  inline void set_allocated_source(::std::string* source);

  // required int32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // repeated string device = 3;
  inline int device_size() const;
  inline void clear_device();
  static const int kDeviceFieldNumber = 3;
  inline const ::std::string& device(int index) const;
  inline ::std::string* mutable_device(int index);
  inline void set_device(int index, const ::std::string& value);
  inline void set_device(int index, const char* value);
  inline void set_device(int index, const char* value, size_t size);
  inline ::std::string* add_device();
  inline void add_device(const ::std::string& value);
  inline void add_device(const char* value);
  inline void add_device(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& device() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_device();

  // @@protoc_insertion_point(class_scope:freedm.broker.sc.MarkerMessage)
 private:
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* source_;
  ::google::protobuf::RepeatedPtrField< ::std::string> device_;
  ::google::protobuf::int32 id_;
  friend void  protobuf_AddDesc_StateCollection_2eproto();
  friend void protobuf_AssignDesc_StateCollection_2eproto();
  friend void protobuf_ShutdownFile_StateCollection_2eproto();

  void InitAsDefaultInstance();
  static MarkerMessage* default_instance_;
};
// -------------------------------------------------------------------

class DeviceSignalStateMessage : public ::google::protobuf::Message {
 public:
  DeviceSignalStateMessage();
  virtual ~DeviceSignalStateMessage();

  DeviceSignalStateMessage(const DeviceSignalStateMessage& from);

  inline DeviceSignalStateMessage& operator=(const DeviceSignalStateMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceSignalStateMessage& default_instance();

  void Swap(DeviceSignalStateMessage* other);

  // implements Message ----------------------------------------------

  DeviceSignalStateMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceSignalStateMessage& from);
  void MergeFrom(const DeviceSignalStateMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // required string signal = 2;
  inline bool has_signal() const;
  inline void clear_signal();
  static const int kSignalFieldNumber = 2;
  inline const ::std::string& signal() const;
  inline void set_signal(const ::std::string& value);
  inline void set_signal(const char* value);
  inline void set_signal(const char* value, size_t size);
  inline ::std::string* mutable_signal();
  inline ::std::string* release_signal();
  inline void set_allocated_signal(::std::string* signal);

  // required float value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline float value() const;
  inline void set_value(float value);

  // required int32 count = 4;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 4;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:freedm.broker.sc.DeviceSignalStateMessage)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_signal();
  inline void clear_has_signal();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* type_;
  ::std::string* signal_;
  float value_;
  ::google::protobuf::int32 count_;
  friend void  protobuf_AddDesc_StateCollection_2eproto();
  friend void protobuf_AssignDesc_StateCollection_2eproto();
  friend void protobuf_ShutdownFile_StateCollection_2eproto();

  void InitAsDefaultInstance();
  static DeviceSignalStateMessage* default_instance_;
};
// -------------------------------------------------------------------

class StateMessage : public ::google::protobuf::Message {
 public:
  StateMessage();
  virtual ~StateMessage();

  StateMessage(const StateMessage& from);

  inline StateMessage& operator=(const StateMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StateMessage& default_instance();

  void Swap(StateMessage* other);

  // implements Message ----------------------------------------------

  StateMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StateMessage& from);
  void MergeFrom(const StateMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string source = 1;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 1;
  inline const ::std::string& source() const;
  inline void set_source(const ::std::string& value);
  inline void set_source(const char* value);
  inline void set_source(const char* value, size_t size);
  inline ::std::string* mutable_source();
  inline ::std::string* release_source();
  inline void set_allocated_source(::std::string* source);

  // required string marker_uuid = 2;
  inline bool has_marker_uuid() const;
  inline void clear_marker_uuid();
  static const int kMarkerUuidFieldNumber = 2;
  inline const ::std::string& marker_uuid() const;
  inline void set_marker_uuid(const ::std::string& value);
  inline void set_marker_uuid(const char* value);
  inline void set_marker_uuid(const char* value, size_t size);
  inline ::std::string* mutable_marker_uuid();
  inline ::std::string* release_marker_uuid();
  inline void set_allocated_marker_uuid(::std::string* marker_uuid);

  // required int32 marker_int = 3;
  inline bool has_marker_int() const;
  inline void clear_marker_int();
  static const int kMarkerIntFieldNumber = 3;
  inline ::google::protobuf::int32 marker_int() const;
  inline void set_marker_int(::google::protobuf::int32 value);

  // repeated .freedm.broker.sc.DeviceSignalStateMessage device_signal_state_message = 4;
  inline int device_signal_state_message_size() const;
  inline void clear_device_signal_state_message();
  static const int kDeviceSignalStateMessageFieldNumber = 4;
  inline const ::freedm::broker::sc::DeviceSignalStateMessage& device_signal_state_message(int index) const;
  inline ::freedm::broker::sc::DeviceSignalStateMessage* mutable_device_signal_state_message(int index);
  inline ::freedm::broker::sc::DeviceSignalStateMessage* add_device_signal_state_message();
  inline const ::google::protobuf::RepeatedPtrField< ::freedm::broker::sc::DeviceSignalStateMessage >&
      device_signal_state_message() const;
  inline ::google::protobuf::RepeatedPtrField< ::freedm::broker::sc::DeviceSignalStateMessage >*
      mutable_device_signal_state_message();

  // @@protoc_insertion_point(class_scope:freedm.broker.sc.StateMessage)
 private:
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_marker_uuid();
  inline void clear_has_marker_uuid();
  inline void set_has_marker_int();
  inline void clear_has_marker_int();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* source_;
  ::std::string* marker_uuid_;
  ::google::protobuf::RepeatedPtrField< ::freedm::broker::sc::DeviceSignalStateMessage > device_signal_state_message_;
  ::google::protobuf::int32 marker_int_;
  friend void  protobuf_AddDesc_StateCollection_2eproto();
  friend void protobuf_AssignDesc_StateCollection_2eproto();
  friend void protobuf_ShutdownFile_StateCollection_2eproto();

  void InitAsDefaultInstance();
  static StateMessage* default_instance_;
};
// -------------------------------------------------------------------

class DeviceSignalRequestMessage : public ::google::protobuf::Message {
 public:
  DeviceSignalRequestMessage();
  virtual ~DeviceSignalRequestMessage();

  DeviceSignalRequestMessage(const DeviceSignalRequestMessage& from);

  inline DeviceSignalRequestMessage& operator=(const DeviceSignalRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceSignalRequestMessage& default_instance();

  void Swap(DeviceSignalRequestMessage* other);

  // implements Message ----------------------------------------------

  DeviceSignalRequestMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceSignalRequestMessage& from);
  void MergeFrom(const DeviceSignalRequestMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // required string signal = 2;
  inline bool has_signal() const;
  inline void clear_signal();
  static const int kSignalFieldNumber = 2;
  inline const ::std::string& signal() const;
  inline void set_signal(const ::std::string& value);
  inline void set_signal(const char* value);
  inline void set_signal(const char* value, size_t size);
  inline ::std::string* mutable_signal();
  inline ::std::string* release_signal();
  inline void set_allocated_signal(::std::string* signal);

  // @@protoc_insertion_point(class_scope:freedm.broker.sc.DeviceSignalRequestMessage)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_signal();
  inline void clear_has_signal();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* type_;
  ::std::string* signal_;
  friend void  protobuf_AddDesc_StateCollection_2eproto();
  friend void protobuf_AssignDesc_StateCollection_2eproto();
  friend void protobuf_ShutdownFile_StateCollection_2eproto();

  void InitAsDefaultInstance();
  static DeviceSignalRequestMessage* default_instance_;
};
// -------------------------------------------------------------------

class RequestMessage : public ::google::protobuf::Message {
 public:
  RequestMessage();
  virtual ~RequestMessage();

  RequestMessage(const RequestMessage& from);

  inline RequestMessage& operator=(const RequestMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestMessage& default_instance();

  void Swap(RequestMessage* other);

  // implements Message ----------------------------------------------

  RequestMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestMessage& from);
  void MergeFrom(const RequestMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string module = 1;
  inline bool has_module() const;
  inline void clear_module();
  static const int kModuleFieldNumber = 1;
  inline const ::std::string& module() const;
  inline void set_module(const ::std::string& value);
  inline void set_module(const char* value);
  inline void set_module(const char* value, size_t size);
  inline ::std::string* mutable_module();
  inline ::std::string* release_module();
  inline void set_allocated_module(::std::string* module);

  // repeated .freedm.broker.sc.DeviceSignalRequestMessage device_signal_request_message = 2;
  inline int device_signal_request_message_size() const;
  inline void clear_device_signal_request_message();
  static const int kDeviceSignalRequestMessageFieldNumber = 2;
  inline const ::freedm::broker::sc::DeviceSignalRequestMessage& device_signal_request_message(int index) const;
  inline ::freedm::broker::sc::DeviceSignalRequestMessage* mutable_device_signal_request_message(int index);
  inline ::freedm::broker::sc::DeviceSignalRequestMessage* add_device_signal_request_message();
  inline const ::google::protobuf::RepeatedPtrField< ::freedm::broker::sc::DeviceSignalRequestMessage >&
      device_signal_request_message() const;
  inline ::google::protobuf::RepeatedPtrField< ::freedm::broker::sc::DeviceSignalRequestMessage >*
      mutable_device_signal_request_message();

  // @@protoc_insertion_point(class_scope:freedm.broker.sc.RequestMessage)
 private:
  inline void set_has_module();
  inline void clear_has_module();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* module_;
  ::google::protobuf::RepeatedPtrField< ::freedm::broker::sc::DeviceSignalRequestMessage > device_signal_request_message_;
  friend void  protobuf_AddDesc_StateCollection_2eproto();
  friend void protobuf_AssignDesc_StateCollection_2eproto();
  friend void protobuf_ShutdownFile_StateCollection_2eproto();

  void InitAsDefaultInstance();
  static RequestMessage* default_instance_;
};
// -------------------------------------------------------------------

class CollectedStateMessage : public ::google::protobuf::Message {
 public:
  CollectedStateMessage();
  virtual ~CollectedStateMessage();

  CollectedStateMessage(const CollectedStateMessage& from);

  inline CollectedStateMessage& operator=(const CollectedStateMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CollectedStateMessage& default_instance();

  void Swap(CollectedStateMessage* other);

  // implements Message ----------------------------------------------

  CollectedStateMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CollectedStateMessage& from);
  void MergeFrom(const CollectedStateMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double gateway = 1;
  inline int gateway_size() const;
  inline void clear_gateway();
  static const int kGatewayFieldNumber = 1;
  inline double gateway(int index) const;
  inline void set_gateway(int index, double value);
  inline void add_gateway(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      gateway() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_gateway();

  // repeated double generation = 2;
  inline int generation_size() const;
  inline void clear_generation();
  static const int kGenerationFieldNumber = 2;
  inline double generation(int index) const;
  inline void set_generation(int index, double value);
  inline void add_generation(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      generation() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_generation();

  // repeated double storage = 3;
  inline int storage_size() const;
  inline void clear_storage();
  static const int kStorageFieldNumber = 3;
  inline double storage(int index) const;
  inline void set_storage(int index, double value);
  inline void add_storage(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      storage() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_storage();

  // repeated double drain = 4;
  inline int drain_size() const;
  inline void clear_drain();
  static const int kDrainFieldNumber = 4;
  inline double drain(int index) const;
  inline void set_drain(int index, double value);
  inline void add_drain(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      drain() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_drain();

  // repeated double state = 5;
  inline int state_size() const;
  inline void clear_state();
  static const int kStateFieldNumber = 5;
  inline double state(int index) const;
  inline void set_state(int index, double value);
  inline void add_state(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      state() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_state();

  // required int32 num_intransit_accepts = 6;
  inline bool has_num_intransit_accepts() const;
  inline void clear_num_intransit_accepts();
  static const int kNumIntransitAcceptsFieldNumber = 6;
  inline ::google::protobuf::int32 num_intransit_accepts() const;
  inline void set_num_intransit_accepts(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:freedm.broker.sc.CollectedStateMessage)
 private:
  inline void set_has_num_intransit_accepts();
  inline void clear_has_num_intransit_accepts();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< double > gateway_;
  ::google::protobuf::RepeatedField< double > generation_;
  ::google::protobuf::RepeatedField< double > storage_;
  ::google::protobuf::RepeatedField< double > drain_;
  ::google::protobuf::RepeatedField< double > state_;
  ::google::protobuf::int32 num_intransit_accepts_;
  friend void  protobuf_AddDesc_StateCollection_2eproto();
  friend void protobuf_AssignDesc_StateCollection_2eproto();
  friend void protobuf_ShutdownFile_StateCollection_2eproto();

  void InitAsDefaultInstance();
  static CollectedStateMessage* default_instance_;
};
// -------------------------------------------------------------------

class StateCollectionMessage : public ::google::protobuf::Message {
 public:
  StateCollectionMessage();
  virtual ~StateCollectionMessage();

  StateCollectionMessage(const StateCollectionMessage& from);

  inline StateCollectionMessage& operator=(const StateCollectionMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StateCollectionMessage& default_instance();

  void Swap(StateCollectionMessage* other);

  // implements Message ----------------------------------------------

  StateCollectionMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StateCollectionMessage& from);
  void MergeFrom(const StateCollectionMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .freedm.broker.sc.MarkerMessage marker_message = 2;
  inline bool has_marker_message() const;
  inline void clear_marker_message();
  static const int kMarkerMessageFieldNumber = 2;
  inline const ::freedm::broker::sc::MarkerMessage& marker_message() const;
  inline ::freedm::broker::sc::MarkerMessage* mutable_marker_message();
  inline ::freedm::broker::sc::MarkerMessage* release_marker_message();
  inline void set_allocated_marker_message(::freedm::broker::sc::MarkerMessage* marker_message);

  // optional .freedm.broker.sc.StateMessage state_message = 3;
  inline bool has_state_message() const;
  inline void clear_state_message();
  static const int kStateMessageFieldNumber = 3;
  inline const ::freedm::broker::sc::StateMessage& state_message() const;
  inline ::freedm::broker::sc::StateMessage* mutable_state_message();
  inline ::freedm::broker::sc::StateMessage* release_state_message();
  inline void set_allocated_state_message(::freedm::broker::sc::StateMessage* state_message);

  // optional .freedm.broker.sc.RequestMessage request_message = 4;
  inline bool has_request_message() const;
  inline void clear_request_message();
  static const int kRequestMessageFieldNumber = 4;
  inline const ::freedm::broker::sc::RequestMessage& request_message() const;
  inline ::freedm::broker::sc::RequestMessage* mutable_request_message();
  inline ::freedm::broker::sc::RequestMessage* release_request_message();
  inline void set_allocated_request_message(::freedm::broker::sc::RequestMessage* request_message);

  // optional .freedm.broker.sc.CollectedStateMessage collected_state_message = 5;
  inline bool has_collected_state_message() const;
  inline void clear_collected_state_message();
  static const int kCollectedStateMessageFieldNumber = 5;
  inline const ::freedm::broker::sc::CollectedStateMessage& collected_state_message() const;
  inline ::freedm::broker::sc::CollectedStateMessage* mutable_collected_state_message();
  inline ::freedm::broker::sc::CollectedStateMessage* release_collected_state_message();
  inline void set_allocated_collected_state_message(::freedm::broker::sc::CollectedStateMessage* collected_state_message);

  // @@protoc_insertion_point(class_scope:freedm.broker.sc.StateCollectionMessage)
 private:
  inline void set_has_marker_message();
  inline void clear_has_marker_message();
  inline void set_has_state_message();
  inline void clear_has_state_message();
  inline void set_has_request_message();
  inline void clear_has_request_message();
  inline void set_has_collected_state_message();
  inline void clear_has_collected_state_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::freedm::broker::sc::MarkerMessage* marker_message_;
  ::freedm::broker::sc::StateMessage* state_message_;
  ::freedm::broker::sc::RequestMessage* request_message_;
  ::freedm::broker::sc::CollectedStateMessage* collected_state_message_;
  friend void  protobuf_AddDesc_StateCollection_2eproto();
  friend void protobuf_AssignDesc_StateCollection_2eproto();
  friend void protobuf_ShutdownFile_StateCollection_2eproto();

  void InitAsDefaultInstance();
  static StateCollectionMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// MarkerMessage

// required string source = 1;
inline bool MarkerMessage::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarkerMessage::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarkerMessage::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarkerMessage::clear_source() {
  if (source_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_->clear();
  }
  clear_has_source();
}
inline const ::std::string& MarkerMessage::source() const {
  // @@protoc_insertion_point(field_get:freedm.broker.sc.MarkerMessage.source)
  return *source_;
}
inline void MarkerMessage::set_source(const ::std::string& value) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_ = new ::std::string;
  }
  source_->assign(value);
  // @@protoc_insertion_point(field_set:freedm.broker.sc.MarkerMessage.source)
}
inline void MarkerMessage::set_source(const char* value) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_ = new ::std::string;
  }
  source_->assign(value);
  // @@protoc_insertion_point(field_set_char:freedm.broker.sc.MarkerMessage.source)
}
inline void MarkerMessage::set_source(const char* value, size_t size) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_ = new ::std::string;
  }
  source_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:freedm.broker.sc.MarkerMessage.source)
}
inline ::std::string* MarkerMessage::mutable_source() {
  set_has_source();
  if (source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:freedm.broker.sc.MarkerMessage.source)
  return source_;
}
inline ::std::string* MarkerMessage::release_source() {
  clear_has_source();
  if (source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = source_;
    source_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MarkerMessage::set_allocated_source(::std::string* source) {
  if (source_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete source_;
  }
  if (source) {
    set_has_source();
    source_ = source;
  } else {
    clear_has_source();
    source_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:freedm.broker.sc.MarkerMessage.source)
}

// required int32 id = 2;
inline bool MarkerMessage::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarkerMessage::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarkerMessage::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarkerMessage::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 MarkerMessage::id() const {
  // @@protoc_insertion_point(field_get:freedm.broker.sc.MarkerMessage.id)
  return id_;
}
inline void MarkerMessage::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:freedm.broker.sc.MarkerMessage.id)
}

// repeated string device = 3;
inline int MarkerMessage::device_size() const {
  return device_.size();
}
inline void MarkerMessage::clear_device() {
  device_.Clear();
}
inline const ::std::string& MarkerMessage::device(int index) const {
  // @@protoc_insertion_point(field_get:freedm.broker.sc.MarkerMessage.device)
  return device_.Get(index);
}
inline ::std::string* MarkerMessage::mutable_device(int index) {
  // @@protoc_insertion_point(field_mutable:freedm.broker.sc.MarkerMessage.device)
  return device_.Mutable(index);
}
inline void MarkerMessage::set_device(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:freedm.broker.sc.MarkerMessage.device)
  device_.Mutable(index)->assign(value);
}
inline void MarkerMessage::set_device(int index, const char* value) {
  device_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:freedm.broker.sc.MarkerMessage.device)
}
inline void MarkerMessage::set_device(int index, const char* value, size_t size) {
  device_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:freedm.broker.sc.MarkerMessage.device)
}
inline ::std::string* MarkerMessage::add_device() {
  return device_.Add();
}
inline void MarkerMessage::add_device(const ::std::string& value) {
  device_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:freedm.broker.sc.MarkerMessage.device)
}
inline void MarkerMessage::add_device(const char* value) {
  device_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:freedm.broker.sc.MarkerMessage.device)
}
inline void MarkerMessage::add_device(const char* value, size_t size) {
  device_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:freedm.broker.sc.MarkerMessage.device)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MarkerMessage::device() const {
  // @@protoc_insertion_point(field_list:freedm.broker.sc.MarkerMessage.device)
  return device_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MarkerMessage::mutable_device() {
  // @@protoc_insertion_point(field_mutable_list:freedm.broker.sc.MarkerMessage.device)
  return &device_;
}

// -------------------------------------------------------------------

// DeviceSignalStateMessage

// required string type = 1;
inline bool DeviceSignalStateMessage::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceSignalStateMessage::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceSignalStateMessage::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceSignalStateMessage::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& DeviceSignalStateMessage::type() const {
  // @@protoc_insertion_point(field_get:freedm.broker.sc.DeviceSignalStateMessage.type)
  return *type_;
}
inline void DeviceSignalStateMessage::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:freedm.broker.sc.DeviceSignalStateMessage.type)
}
inline void DeviceSignalStateMessage::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:freedm.broker.sc.DeviceSignalStateMessage.type)
}
inline void DeviceSignalStateMessage::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:freedm.broker.sc.DeviceSignalStateMessage.type)
}
inline ::std::string* DeviceSignalStateMessage::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:freedm.broker.sc.DeviceSignalStateMessage.type)
  return type_;
}
inline ::std::string* DeviceSignalStateMessage::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DeviceSignalStateMessage::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:freedm.broker.sc.DeviceSignalStateMessage.type)
}

// required string signal = 2;
inline bool DeviceSignalStateMessage::has_signal() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceSignalStateMessage::set_has_signal() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeviceSignalStateMessage::clear_has_signal() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceSignalStateMessage::clear_signal() {
  if (signal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signal_->clear();
  }
  clear_has_signal();
}
inline const ::std::string& DeviceSignalStateMessage::signal() const {
  // @@protoc_insertion_point(field_get:freedm.broker.sc.DeviceSignalStateMessage.signal)
  return *signal_;
}
inline void DeviceSignalStateMessage::set_signal(const ::std::string& value) {
  set_has_signal();
  if (signal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signal_ = new ::std::string;
  }
  signal_->assign(value);
  // @@protoc_insertion_point(field_set:freedm.broker.sc.DeviceSignalStateMessage.signal)
}
inline void DeviceSignalStateMessage::set_signal(const char* value) {
  set_has_signal();
  if (signal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signal_ = new ::std::string;
  }
  signal_->assign(value);
  // @@protoc_insertion_point(field_set_char:freedm.broker.sc.DeviceSignalStateMessage.signal)
}
inline void DeviceSignalStateMessage::set_signal(const char* value, size_t size) {
  set_has_signal();
  if (signal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signal_ = new ::std::string;
  }
  signal_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:freedm.broker.sc.DeviceSignalStateMessage.signal)
}
inline ::std::string* DeviceSignalStateMessage::mutable_signal() {
  set_has_signal();
  if (signal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signal_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:freedm.broker.sc.DeviceSignalStateMessage.signal)
  return signal_;
}
inline ::std::string* DeviceSignalStateMessage::release_signal() {
  clear_has_signal();
  if (signal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = signal_;
    signal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DeviceSignalStateMessage::set_allocated_signal(::std::string* signal) {
  if (signal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signal_;
  }
  if (signal) {
    set_has_signal();
    signal_ = signal;
  } else {
    clear_has_signal();
    signal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:freedm.broker.sc.DeviceSignalStateMessage.signal)
}

// required float value = 3;
inline bool DeviceSignalStateMessage::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceSignalStateMessage::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeviceSignalStateMessage::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeviceSignalStateMessage::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline float DeviceSignalStateMessage::value() const {
  // @@protoc_insertion_point(field_get:freedm.broker.sc.DeviceSignalStateMessage.value)
  return value_;
}
inline void DeviceSignalStateMessage::set_value(float value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:freedm.broker.sc.DeviceSignalStateMessage.value)
}

// required int32 count = 4;
inline bool DeviceSignalStateMessage::has_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeviceSignalStateMessage::set_has_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DeviceSignalStateMessage::clear_has_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DeviceSignalStateMessage::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 DeviceSignalStateMessage::count() const {
  // @@protoc_insertion_point(field_get:freedm.broker.sc.DeviceSignalStateMessage.count)
  return count_;
}
inline void DeviceSignalStateMessage::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:freedm.broker.sc.DeviceSignalStateMessage.count)
}

// -------------------------------------------------------------------

// StateMessage

// required string source = 1;
inline bool StateMessage::has_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StateMessage::set_has_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StateMessage::clear_has_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StateMessage::clear_source() {
  if (source_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_->clear();
  }
  clear_has_source();
}
inline const ::std::string& StateMessage::source() const {
  // @@protoc_insertion_point(field_get:freedm.broker.sc.StateMessage.source)
  return *source_;
}
inline void StateMessage::set_source(const ::std::string& value) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_ = new ::std::string;
  }
  source_->assign(value);
  // @@protoc_insertion_point(field_set:freedm.broker.sc.StateMessage.source)
}
inline void StateMessage::set_source(const char* value) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_ = new ::std::string;
  }
  source_->assign(value);
  // @@protoc_insertion_point(field_set_char:freedm.broker.sc.StateMessage.source)
}
inline void StateMessage::set_source(const char* value, size_t size) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_ = new ::std::string;
  }
  source_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:freedm.broker.sc.StateMessage.source)
}
inline ::std::string* StateMessage::mutable_source() {
  set_has_source();
  if (source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:freedm.broker.sc.StateMessage.source)
  return source_;
}
inline ::std::string* StateMessage::release_source() {
  clear_has_source();
  if (source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = source_;
    source_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StateMessage::set_allocated_source(::std::string* source) {
  if (source_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete source_;
  }
  if (source) {
    set_has_source();
    source_ = source;
  } else {
    clear_has_source();
    source_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:freedm.broker.sc.StateMessage.source)
}

// required string marker_uuid = 2;
inline bool StateMessage::has_marker_uuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StateMessage::set_has_marker_uuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StateMessage::clear_has_marker_uuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StateMessage::clear_marker_uuid() {
  if (marker_uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    marker_uuid_->clear();
  }
  clear_has_marker_uuid();
}
inline const ::std::string& StateMessage::marker_uuid() const {
  // @@protoc_insertion_point(field_get:freedm.broker.sc.StateMessage.marker_uuid)
  return *marker_uuid_;
}
inline void StateMessage::set_marker_uuid(const ::std::string& value) {
  set_has_marker_uuid();
  if (marker_uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    marker_uuid_ = new ::std::string;
  }
  marker_uuid_->assign(value);
  // @@protoc_insertion_point(field_set:freedm.broker.sc.StateMessage.marker_uuid)
}
inline void StateMessage::set_marker_uuid(const char* value) {
  set_has_marker_uuid();
  if (marker_uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    marker_uuid_ = new ::std::string;
  }
  marker_uuid_->assign(value);
  // @@protoc_insertion_point(field_set_char:freedm.broker.sc.StateMessage.marker_uuid)
}
inline void StateMessage::set_marker_uuid(const char* value, size_t size) {
  set_has_marker_uuid();
  if (marker_uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    marker_uuid_ = new ::std::string;
  }
  marker_uuid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:freedm.broker.sc.StateMessage.marker_uuid)
}
inline ::std::string* StateMessage::mutable_marker_uuid() {
  set_has_marker_uuid();
  if (marker_uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    marker_uuid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:freedm.broker.sc.StateMessage.marker_uuid)
  return marker_uuid_;
}
inline ::std::string* StateMessage::release_marker_uuid() {
  clear_has_marker_uuid();
  if (marker_uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = marker_uuid_;
    marker_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StateMessage::set_allocated_marker_uuid(::std::string* marker_uuid) {
  if (marker_uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete marker_uuid_;
  }
  if (marker_uuid) {
    set_has_marker_uuid();
    marker_uuid_ = marker_uuid;
  } else {
    clear_has_marker_uuid();
    marker_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:freedm.broker.sc.StateMessage.marker_uuid)
}

// required int32 marker_int = 3;
inline bool StateMessage::has_marker_int() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StateMessage::set_has_marker_int() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StateMessage::clear_has_marker_int() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StateMessage::clear_marker_int() {
  marker_int_ = 0;
  clear_has_marker_int();
}
inline ::google::protobuf::int32 StateMessage::marker_int() const {
  // @@protoc_insertion_point(field_get:freedm.broker.sc.StateMessage.marker_int)
  return marker_int_;
}
inline void StateMessage::set_marker_int(::google::protobuf::int32 value) {
  set_has_marker_int();
  marker_int_ = value;
  // @@protoc_insertion_point(field_set:freedm.broker.sc.StateMessage.marker_int)
}

// repeated .freedm.broker.sc.DeviceSignalStateMessage device_signal_state_message = 4;
inline int StateMessage::device_signal_state_message_size() const {
  return device_signal_state_message_.size();
}
inline void StateMessage::clear_device_signal_state_message() {
  device_signal_state_message_.Clear();
}
inline const ::freedm::broker::sc::DeviceSignalStateMessage& StateMessage::device_signal_state_message(int index) const {
  // @@protoc_insertion_point(field_get:freedm.broker.sc.StateMessage.device_signal_state_message)
  return device_signal_state_message_.Get(index);
}
inline ::freedm::broker::sc::DeviceSignalStateMessage* StateMessage::mutable_device_signal_state_message(int index) {
  // @@protoc_insertion_point(field_mutable:freedm.broker.sc.StateMessage.device_signal_state_message)
  return device_signal_state_message_.Mutable(index);
}
inline ::freedm::broker::sc::DeviceSignalStateMessage* StateMessage::add_device_signal_state_message() {
  // @@protoc_insertion_point(field_add:freedm.broker.sc.StateMessage.device_signal_state_message)
  return device_signal_state_message_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::freedm::broker::sc::DeviceSignalStateMessage >&
StateMessage::device_signal_state_message() const {
  // @@protoc_insertion_point(field_list:freedm.broker.sc.StateMessage.device_signal_state_message)
  return device_signal_state_message_;
}
inline ::google::protobuf::RepeatedPtrField< ::freedm::broker::sc::DeviceSignalStateMessage >*
StateMessage::mutable_device_signal_state_message() {
  // @@protoc_insertion_point(field_mutable_list:freedm.broker.sc.StateMessage.device_signal_state_message)
  return &device_signal_state_message_;
}

// -------------------------------------------------------------------

// DeviceSignalRequestMessage

// required string type = 1;
inline bool DeviceSignalRequestMessage::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceSignalRequestMessage::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceSignalRequestMessage::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceSignalRequestMessage::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& DeviceSignalRequestMessage::type() const {
  // @@protoc_insertion_point(field_get:freedm.broker.sc.DeviceSignalRequestMessage.type)
  return *type_;
}
inline void DeviceSignalRequestMessage::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:freedm.broker.sc.DeviceSignalRequestMessage.type)
}
inline void DeviceSignalRequestMessage::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:freedm.broker.sc.DeviceSignalRequestMessage.type)
}
inline void DeviceSignalRequestMessage::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:freedm.broker.sc.DeviceSignalRequestMessage.type)
}
inline ::std::string* DeviceSignalRequestMessage::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:freedm.broker.sc.DeviceSignalRequestMessage.type)
  return type_;
}
inline ::std::string* DeviceSignalRequestMessage::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DeviceSignalRequestMessage::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:freedm.broker.sc.DeviceSignalRequestMessage.type)
}

// required string signal = 2;
inline bool DeviceSignalRequestMessage::has_signal() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceSignalRequestMessage::set_has_signal() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeviceSignalRequestMessage::clear_has_signal() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceSignalRequestMessage::clear_signal() {
  if (signal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signal_->clear();
  }
  clear_has_signal();
}
inline const ::std::string& DeviceSignalRequestMessage::signal() const {
  // @@protoc_insertion_point(field_get:freedm.broker.sc.DeviceSignalRequestMessage.signal)
  return *signal_;
}
inline void DeviceSignalRequestMessage::set_signal(const ::std::string& value) {
  set_has_signal();
  if (signal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signal_ = new ::std::string;
  }
  signal_->assign(value);
  // @@protoc_insertion_point(field_set:freedm.broker.sc.DeviceSignalRequestMessage.signal)
}
inline void DeviceSignalRequestMessage::set_signal(const char* value) {
  set_has_signal();
  if (signal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signal_ = new ::std::string;
  }
  signal_->assign(value);
  // @@protoc_insertion_point(field_set_char:freedm.broker.sc.DeviceSignalRequestMessage.signal)
}
inline void DeviceSignalRequestMessage::set_signal(const char* value, size_t size) {
  set_has_signal();
  if (signal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signal_ = new ::std::string;
  }
  signal_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:freedm.broker.sc.DeviceSignalRequestMessage.signal)
}
inline ::std::string* DeviceSignalRequestMessage::mutable_signal() {
  set_has_signal();
  if (signal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signal_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:freedm.broker.sc.DeviceSignalRequestMessage.signal)
  return signal_;
}
inline ::std::string* DeviceSignalRequestMessage::release_signal() {
  clear_has_signal();
  if (signal_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = signal_;
    signal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DeviceSignalRequestMessage::set_allocated_signal(::std::string* signal) {
  if (signal_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signal_;
  }
  if (signal) {
    set_has_signal();
    signal_ = signal;
  } else {
    clear_has_signal();
    signal_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:freedm.broker.sc.DeviceSignalRequestMessage.signal)
}

// -------------------------------------------------------------------

// RequestMessage

// required string module = 1;
inline bool RequestMessage::has_module() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestMessage::set_has_module() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestMessage::clear_has_module() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestMessage::clear_module() {
  if (module_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    module_->clear();
  }
  clear_has_module();
}
inline const ::std::string& RequestMessage::module() const {
  // @@protoc_insertion_point(field_get:freedm.broker.sc.RequestMessage.module)
  return *module_;
}
inline void RequestMessage::set_module(const ::std::string& value) {
  set_has_module();
  if (module_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    module_ = new ::std::string;
  }
  module_->assign(value);
  // @@protoc_insertion_point(field_set:freedm.broker.sc.RequestMessage.module)
}
inline void RequestMessage::set_module(const char* value) {
  set_has_module();
  if (module_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    module_ = new ::std::string;
  }
  module_->assign(value);
  // @@protoc_insertion_point(field_set_char:freedm.broker.sc.RequestMessage.module)
}
inline void RequestMessage::set_module(const char* value, size_t size) {
  set_has_module();
  if (module_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    module_ = new ::std::string;
  }
  module_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:freedm.broker.sc.RequestMessage.module)
}
inline ::std::string* RequestMessage::mutable_module() {
  set_has_module();
  if (module_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    module_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:freedm.broker.sc.RequestMessage.module)
  return module_;
}
inline ::std::string* RequestMessage::release_module() {
  clear_has_module();
  if (module_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = module_;
    module_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RequestMessage::set_allocated_module(::std::string* module) {
  if (module_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete module_;
  }
  if (module) {
    set_has_module();
    module_ = module;
  } else {
    clear_has_module();
    module_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:freedm.broker.sc.RequestMessage.module)
}

// repeated .freedm.broker.sc.DeviceSignalRequestMessage device_signal_request_message = 2;
inline int RequestMessage::device_signal_request_message_size() const {
  return device_signal_request_message_.size();
}
inline void RequestMessage::clear_device_signal_request_message() {
  device_signal_request_message_.Clear();
}
inline const ::freedm::broker::sc::DeviceSignalRequestMessage& RequestMessage::device_signal_request_message(int index) const {
  // @@protoc_insertion_point(field_get:freedm.broker.sc.RequestMessage.device_signal_request_message)
  return device_signal_request_message_.Get(index);
}
inline ::freedm::broker::sc::DeviceSignalRequestMessage* RequestMessage::mutable_device_signal_request_message(int index) {
  // @@protoc_insertion_point(field_mutable:freedm.broker.sc.RequestMessage.device_signal_request_message)
  return device_signal_request_message_.Mutable(index);
}
inline ::freedm::broker::sc::DeviceSignalRequestMessage* RequestMessage::add_device_signal_request_message() {
  // @@protoc_insertion_point(field_add:freedm.broker.sc.RequestMessage.device_signal_request_message)
  return device_signal_request_message_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::freedm::broker::sc::DeviceSignalRequestMessage >&
RequestMessage::device_signal_request_message() const {
  // @@protoc_insertion_point(field_list:freedm.broker.sc.RequestMessage.device_signal_request_message)
  return device_signal_request_message_;
}
inline ::google::protobuf::RepeatedPtrField< ::freedm::broker::sc::DeviceSignalRequestMessage >*
RequestMessage::mutable_device_signal_request_message() {
  // @@protoc_insertion_point(field_mutable_list:freedm.broker.sc.RequestMessage.device_signal_request_message)
  return &device_signal_request_message_;
}

// -------------------------------------------------------------------

// CollectedStateMessage

// repeated double gateway = 1;
inline int CollectedStateMessage::gateway_size() const {
  return gateway_.size();
}
inline void CollectedStateMessage::clear_gateway() {
  gateway_.Clear();
}
inline double CollectedStateMessage::gateway(int index) const {
  // @@protoc_insertion_point(field_get:freedm.broker.sc.CollectedStateMessage.gateway)
  return gateway_.Get(index);
}
inline void CollectedStateMessage::set_gateway(int index, double value) {
  gateway_.Set(index, value);
  // @@protoc_insertion_point(field_set:freedm.broker.sc.CollectedStateMessage.gateway)
}
inline void CollectedStateMessage::add_gateway(double value) {
  gateway_.Add(value);
  // @@protoc_insertion_point(field_add:freedm.broker.sc.CollectedStateMessage.gateway)
}
inline const ::google::protobuf::RepeatedField< double >&
CollectedStateMessage::gateway() const {
  // @@protoc_insertion_point(field_list:freedm.broker.sc.CollectedStateMessage.gateway)
  return gateway_;
}
inline ::google::protobuf::RepeatedField< double >*
CollectedStateMessage::mutable_gateway() {
  // @@protoc_insertion_point(field_mutable_list:freedm.broker.sc.CollectedStateMessage.gateway)
  return &gateway_;
}

// repeated double generation = 2;
inline int CollectedStateMessage::generation_size() const {
  return generation_.size();
}
inline void CollectedStateMessage::clear_generation() {
  generation_.Clear();
}
inline double CollectedStateMessage::generation(int index) const {
  // @@protoc_insertion_point(field_get:freedm.broker.sc.CollectedStateMessage.generation)
  return generation_.Get(index);
}
inline void CollectedStateMessage::set_generation(int index, double value) {
  generation_.Set(index, value);
  // @@protoc_insertion_point(field_set:freedm.broker.sc.CollectedStateMessage.generation)
}
inline void CollectedStateMessage::add_generation(double value) {
  generation_.Add(value);
  // @@protoc_insertion_point(field_add:freedm.broker.sc.CollectedStateMessage.generation)
}
inline const ::google::protobuf::RepeatedField< double >&
CollectedStateMessage::generation() const {
  // @@protoc_insertion_point(field_list:freedm.broker.sc.CollectedStateMessage.generation)
  return generation_;
}
inline ::google::protobuf::RepeatedField< double >*
CollectedStateMessage::mutable_generation() {
  // @@protoc_insertion_point(field_mutable_list:freedm.broker.sc.CollectedStateMessage.generation)
  return &generation_;
}

// repeated double storage = 3;
inline int CollectedStateMessage::storage_size() const {
  return storage_.size();
}
inline void CollectedStateMessage::clear_storage() {
  storage_.Clear();
}
inline double CollectedStateMessage::storage(int index) const {
  // @@protoc_insertion_point(field_get:freedm.broker.sc.CollectedStateMessage.storage)
  return storage_.Get(index);
}
inline void CollectedStateMessage::set_storage(int index, double value) {
  storage_.Set(index, value);
  // @@protoc_insertion_point(field_set:freedm.broker.sc.CollectedStateMessage.storage)
}
inline void CollectedStateMessage::add_storage(double value) {
  storage_.Add(value);
  // @@protoc_insertion_point(field_add:freedm.broker.sc.CollectedStateMessage.storage)
}
inline const ::google::protobuf::RepeatedField< double >&
CollectedStateMessage::storage() const {
  // @@protoc_insertion_point(field_list:freedm.broker.sc.CollectedStateMessage.storage)
  return storage_;
}
inline ::google::protobuf::RepeatedField< double >*
CollectedStateMessage::mutable_storage() {
  // @@protoc_insertion_point(field_mutable_list:freedm.broker.sc.CollectedStateMessage.storage)
  return &storage_;
}

// repeated double drain = 4;
inline int CollectedStateMessage::drain_size() const {
  return drain_.size();
}
inline void CollectedStateMessage::clear_drain() {
  drain_.Clear();
}
inline double CollectedStateMessage::drain(int index) const {
  // @@protoc_insertion_point(field_get:freedm.broker.sc.CollectedStateMessage.drain)
  return drain_.Get(index);
}
inline void CollectedStateMessage::set_drain(int index, double value) {
  drain_.Set(index, value);
  // @@protoc_insertion_point(field_set:freedm.broker.sc.CollectedStateMessage.drain)
}
inline void CollectedStateMessage::add_drain(double value) {
  drain_.Add(value);
  // @@protoc_insertion_point(field_add:freedm.broker.sc.CollectedStateMessage.drain)
}
inline const ::google::protobuf::RepeatedField< double >&
CollectedStateMessage::drain() const {
  // @@protoc_insertion_point(field_list:freedm.broker.sc.CollectedStateMessage.drain)
  return drain_;
}
inline ::google::protobuf::RepeatedField< double >*
CollectedStateMessage::mutable_drain() {
  // @@protoc_insertion_point(field_mutable_list:freedm.broker.sc.CollectedStateMessage.drain)
  return &drain_;
}

// repeated double state = 5;
inline int CollectedStateMessage::state_size() const {
  return state_.size();
}
inline void CollectedStateMessage::clear_state() {
  state_.Clear();
}
inline double CollectedStateMessage::state(int index) const {
  // @@protoc_insertion_point(field_get:freedm.broker.sc.CollectedStateMessage.state)
  return state_.Get(index);
}
inline void CollectedStateMessage::set_state(int index, double value) {
  state_.Set(index, value);
  // @@protoc_insertion_point(field_set:freedm.broker.sc.CollectedStateMessage.state)
}
inline void CollectedStateMessage::add_state(double value) {
  state_.Add(value);
  // @@protoc_insertion_point(field_add:freedm.broker.sc.CollectedStateMessage.state)
}
inline const ::google::protobuf::RepeatedField< double >&
CollectedStateMessage::state() const {
  // @@protoc_insertion_point(field_list:freedm.broker.sc.CollectedStateMessage.state)
  return state_;
}
inline ::google::protobuf::RepeatedField< double >*
CollectedStateMessage::mutable_state() {
  // @@protoc_insertion_point(field_mutable_list:freedm.broker.sc.CollectedStateMessage.state)
  return &state_;
}

// required int32 num_intransit_accepts = 6;
inline bool CollectedStateMessage::has_num_intransit_accepts() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CollectedStateMessage::set_has_num_intransit_accepts() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CollectedStateMessage::clear_has_num_intransit_accepts() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CollectedStateMessage::clear_num_intransit_accepts() {
  num_intransit_accepts_ = 0;
  clear_has_num_intransit_accepts();
}
inline ::google::protobuf::int32 CollectedStateMessage::num_intransit_accepts() const {
  // @@protoc_insertion_point(field_get:freedm.broker.sc.CollectedStateMessage.num_intransit_accepts)
  return num_intransit_accepts_;
}
inline void CollectedStateMessage::set_num_intransit_accepts(::google::protobuf::int32 value) {
  set_has_num_intransit_accepts();
  num_intransit_accepts_ = value;
  // @@protoc_insertion_point(field_set:freedm.broker.sc.CollectedStateMessage.num_intransit_accepts)
}

// -------------------------------------------------------------------

// StateCollectionMessage

// optional .freedm.broker.sc.MarkerMessage marker_message = 2;
inline bool StateCollectionMessage::has_marker_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StateCollectionMessage::set_has_marker_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StateCollectionMessage::clear_has_marker_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StateCollectionMessage::clear_marker_message() {
  if (marker_message_ != NULL) marker_message_->::freedm::broker::sc::MarkerMessage::Clear();
  clear_has_marker_message();
}
inline const ::freedm::broker::sc::MarkerMessage& StateCollectionMessage::marker_message() const {
  // @@protoc_insertion_point(field_get:freedm.broker.sc.StateCollectionMessage.marker_message)
  return marker_message_ != NULL ? *marker_message_ : *default_instance_->marker_message_;
}
inline ::freedm::broker::sc::MarkerMessage* StateCollectionMessage::mutable_marker_message() {
  set_has_marker_message();
  if (marker_message_ == NULL) marker_message_ = new ::freedm::broker::sc::MarkerMessage;
  // @@protoc_insertion_point(field_mutable:freedm.broker.sc.StateCollectionMessage.marker_message)
  return marker_message_;
}
inline ::freedm::broker::sc::MarkerMessage* StateCollectionMessage::release_marker_message() {
  clear_has_marker_message();
  ::freedm::broker::sc::MarkerMessage* temp = marker_message_;
  marker_message_ = NULL;
  return temp;
}
inline void StateCollectionMessage::set_allocated_marker_message(::freedm::broker::sc::MarkerMessage* marker_message) {
  delete marker_message_;
  marker_message_ = marker_message;
  if (marker_message) {
    set_has_marker_message();
  } else {
    clear_has_marker_message();
  }
  // @@protoc_insertion_point(field_set_allocated:freedm.broker.sc.StateCollectionMessage.marker_message)
}

// optional .freedm.broker.sc.StateMessage state_message = 3;
inline bool StateCollectionMessage::has_state_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StateCollectionMessage::set_has_state_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StateCollectionMessage::clear_has_state_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StateCollectionMessage::clear_state_message() {
  if (state_message_ != NULL) state_message_->::freedm::broker::sc::StateMessage::Clear();
  clear_has_state_message();
}
inline const ::freedm::broker::sc::StateMessage& StateCollectionMessage::state_message() const {
  // @@protoc_insertion_point(field_get:freedm.broker.sc.StateCollectionMessage.state_message)
  return state_message_ != NULL ? *state_message_ : *default_instance_->state_message_;
}
inline ::freedm::broker::sc::StateMessage* StateCollectionMessage::mutable_state_message() {
  set_has_state_message();
  if (state_message_ == NULL) state_message_ = new ::freedm::broker::sc::StateMessage;
  // @@protoc_insertion_point(field_mutable:freedm.broker.sc.StateCollectionMessage.state_message)
  return state_message_;
}
inline ::freedm::broker::sc::StateMessage* StateCollectionMessage::release_state_message() {
  clear_has_state_message();
  ::freedm::broker::sc::StateMessage* temp = state_message_;
  state_message_ = NULL;
  return temp;
}
inline void StateCollectionMessage::set_allocated_state_message(::freedm::broker::sc::StateMessage* state_message) {
  delete state_message_;
  state_message_ = state_message;
  if (state_message) {
    set_has_state_message();
  } else {
    clear_has_state_message();
  }
  // @@protoc_insertion_point(field_set_allocated:freedm.broker.sc.StateCollectionMessage.state_message)
}

// optional .freedm.broker.sc.RequestMessage request_message = 4;
inline bool StateCollectionMessage::has_request_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StateCollectionMessage::set_has_request_message() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StateCollectionMessage::clear_has_request_message() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StateCollectionMessage::clear_request_message() {
  if (request_message_ != NULL) request_message_->::freedm::broker::sc::RequestMessage::Clear();
  clear_has_request_message();
}
inline const ::freedm::broker::sc::RequestMessage& StateCollectionMessage::request_message() const {
  // @@protoc_insertion_point(field_get:freedm.broker.sc.StateCollectionMessage.request_message)
  return request_message_ != NULL ? *request_message_ : *default_instance_->request_message_;
}
inline ::freedm::broker::sc::RequestMessage* StateCollectionMessage::mutable_request_message() {
  set_has_request_message();
  if (request_message_ == NULL) request_message_ = new ::freedm::broker::sc::RequestMessage;
  // @@protoc_insertion_point(field_mutable:freedm.broker.sc.StateCollectionMessage.request_message)
  return request_message_;
}
inline ::freedm::broker::sc::RequestMessage* StateCollectionMessage::release_request_message() {
  clear_has_request_message();
  ::freedm::broker::sc::RequestMessage* temp = request_message_;
  request_message_ = NULL;
  return temp;
}
inline void StateCollectionMessage::set_allocated_request_message(::freedm::broker::sc::RequestMessage* request_message) {
  delete request_message_;
  request_message_ = request_message;
  if (request_message) {
    set_has_request_message();
  } else {
    clear_has_request_message();
  }
  // @@protoc_insertion_point(field_set_allocated:freedm.broker.sc.StateCollectionMessage.request_message)
}

// optional .freedm.broker.sc.CollectedStateMessage collected_state_message = 5;
inline bool StateCollectionMessage::has_collected_state_message() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StateCollectionMessage::set_has_collected_state_message() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StateCollectionMessage::clear_has_collected_state_message() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StateCollectionMessage::clear_collected_state_message() {
  if (collected_state_message_ != NULL) collected_state_message_->::freedm::broker::sc::CollectedStateMessage::Clear();
  clear_has_collected_state_message();
}
inline const ::freedm::broker::sc::CollectedStateMessage& StateCollectionMessage::collected_state_message() const {
  // @@protoc_insertion_point(field_get:freedm.broker.sc.StateCollectionMessage.collected_state_message)
  return collected_state_message_ != NULL ? *collected_state_message_ : *default_instance_->collected_state_message_;
}
inline ::freedm::broker::sc::CollectedStateMessage* StateCollectionMessage::mutable_collected_state_message() {
  set_has_collected_state_message();
  if (collected_state_message_ == NULL) collected_state_message_ = new ::freedm::broker::sc::CollectedStateMessage;
  // @@protoc_insertion_point(field_mutable:freedm.broker.sc.StateCollectionMessage.collected_state_message)
  return collected_state_message_;
}
inline ::freedm::broker::sc::CollectedStateMessage* StateCollectionMessage::release_collected_state_message() {
  clear_has_collected_state_message();
  ::freedm::broker::sc::CollectedStateMessage* temp = collected_state_message_;
  collected_state_message_ = NULL;
  return temp;
}
inline void StateCollectionMessage::set_allocated_collected_state_message(::freedm::broker::sc::CollectedStateMessage* collected_state_message) {
  delete collected_state_message_;
  collected_state_message_ = collected_state_message;
  if (collected_state_message) {
    set_has_collected_state_message();
  } else {
    clear_has_collected_state_message();
  }
  // @@protoc_insertion_point(field_set_allocated:freedm.broker.sc.StateCollectionMessage.collected_state_message)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace sc
}  // namespace broker
}  // namespace freedm

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_StateCollection_2eproto__INCLUDED
